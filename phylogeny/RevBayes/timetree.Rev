############################################################################
# Timetree full model specification and MCMC set up for estimating
# time-calibrated phylogenies under a strict clock model
############################################################################

setOption("useScaling","true")
### Load the sequence alignment
D <- readDiscreteCharacterData(file="concatenate.fasta")
### initialize an iterator for the moves vector
mi = 1
n_sites <- D.nchar()


############################################################################
# Birth-death, rho=55/186, fixed topology
############################################################################
## read in the tree
backbone <- readTrees("timetree_rev_constrained/backbone_rooted_ultram.tre")[1]
n_taxa <- backbone.ntips()
taxa <- backbone.taxa()

#######################################
###### Birth-death process model #####
#######################################
diversification ~ dnExponential(10.0)
turnover ~ dnBeta(2.0, 2.0)
denom := abs(1.0 - turnover)
birth_rate := diversification / denom
death_rate := (turnover * diversification) / denom
### fix rho to 0.2957, since there are ~186 described species and we have sampled 55
rho <- 0.2957
### the root age is an independent stochastic node with a lognormal prior
#arbitrary numbers since we donâ€™t have time calibrations from fossils
mean_ra <- 0.5
stdv_ra <- 0.001
mu_ra <- ln(mean_ra) - ((stdv_ra*stdv_ra) * 0.5)
root_time ~ dnLnorm(mu_ra, stdv_ra, offset=1)
#######################
#Constraints on clades#
#######################
### the time tree is a stochastic node modeled by the constant rate birth-death process
(dnBDP)
tree_prior = dnBDP(lambda=birth_rate, mu=death_rate, rho=rho, rootAge=root_time,
samplingStrategy="uniform", condition="nTaxa", taxa=taxa)
timetree ~ dnConstrainedTopology(tree_prior, backbone = backbone)
timetree.setValue(backbone)
moves[mi++] = mvScale(diversification,lambda=1.0,tune=true,weight=3.0)
moves[mi++] = mvSlide(turnover,delta=1.0,tune=true,weight=3.0)
####### Tree Moves #######
### add moves on the tree node times, including the root time, which is outside of the timetree
moves[mi++] = mvNodeTimeSlideUniform(timetree, weight=30.0)
### and moves for the tree topology
moves[mi++] = mvNNI(timetree, weight=8.0)
moves[mi++] = mvNarrow(timetree, weight=8.0)
moves[mi++] = mvFNPR(timetree, weight=8.0)
############################################################################
# Timetree UCLN relaxed-clock model specification
############################################################################
n_branches <- 2 * n_taxa - 3
ucln_mean ~ dnExponential(2.0)
ucln_sigma ~ dnExponential(3.0)
ucln_var := ucln_sigma * ucln_sigma
ucln_mu := ln(ucln_mean) - (ucln_var * 0.5)
moves[mi++] = mvScale(ucln_mean, lambda=1.0, tune=true, weight=4.0)
moves[mi++] = mvScale(ucln_sigma, lambda=0.5, tune=true, weight=4.0)
for(i in 1:n_branches){
branch_rates[i] ~ dnLnorm(ucln_mu, ucln_sigma)
moves[mi++] = mvScale(branch_rates[i],lambda=1.0,tune=true,weight=2.0)
}
moves[mi++] = mvVectorScale(branch_rates,lambda=1.0,tune=true,weight=2.0)
moves[mi++] = mvVectorSingleElementScale(branch_rates,lambda=30.0,tune=true,weight=1.0)
mean_rt := mean(branch_rates)
n_species <- D.ntaxa()
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
moves[mi++] = mvSimplexElementScale(er, alpha=10, tune=true, weight=3)
pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
moves[mi++] = mvSimplexElementScale(pi, alpha=10, tune=true, weight=2)
Q := fnGTR(er,pi)
phySeq ~ dnPhyloCTMC(tree=timetree, Q=Q, branchRates=mean_rt, nSites=n_sites,
type="DNA")
phySeq.clamp(D)
#############################
############ MCMC ###########
#############################
mymodel = model(er)
### set up the monitors that will output parameter values to file and screen
monitors[1] = mnModel(filename="output/TimeTree_siphs_mcmc.log", printgen=10)
monitors[2] = mnFile(filename="output/TimeTree_siphs_mcmc.trees", printgen=10, timetree)
#monitors[3] = mnScreen(printgen=100, root_time)
### workspace mcmc ###
mymcmc = mcmc(mymodel, monitors, moves)
### pre-burnin to tune the proposals ###
mymcmc.burnin(generations=5000,tuningInterval=100)
### run the MCMC ###
mymcmc.run(generations=10000)
### display proposal acceptance rates and tuning ###
mymcmc.operatorSummary()
### summarize the trees ###
tt = readTreeTrace("output/TimeTree_siphs_mcmc.trees", "clock")
tt.summarize()
### write MAP tree to file
mapTree(tt, "output/TimeTree_siphs_mcmc_MAP.tre")
q()